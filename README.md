# Simple 2651 UART System

This circuit provides a simple test environment for a **2651 Programmable Communications Interface (PCI) UART** chip. In this specific example I used an *SCN2651* chip, but this software is forward compatible with all of the serial IC-s based on the 2651 architecture (For example, the 2661).

This system serves as an introductory circuit to the world of UARTs, aiming to minimize complexity while keeping the component count low. I created similar circuits using other popular UART/USART chips, like the 8250 and the 8251. Feel free to check them out!

## Breadboard Photo

![Breadboard Photo](https://github.com/bazsimarkus/Simple-2651-UART-System-with-Arduino/raw/main/images/2651_breadboard.jpg)

## Components Needed

- 2651 PCI UART chip
- Arduino board (Uno, Nano, both works, the important thing is that it should operate on 5V voltage)
- USB-TTL Serial converter for testing (FTDI will also suffice)
  > The USB-TTL Serial adapter is necessary to test if the circuit is functioning correctly. Refer to "How to use" for details.

## How to Use

1. Connect your Arduino board to the 2651 PCI UART chip based on the included schematics.
2. Upload the 2651.ino source code to the Arduino board.
3. Connect the USB-TTL Serial converter to the PC and to the TxD/RxD pins of the 2651 PCI UART chip
4. Open a serial terminal program (for example, RealTerm), select the COM port of your USB-Serial converter, and set up the terminal to use 9600 baud, 8-bit data, no parity, and 1 stop bit.
5. You should be receiving the string "TESTABCD" once every second.

## How It Works

The Arduino sends 8-bit ASCII characters to the UART chip, then the chip converts it to serial data (9600 baud, 8-bit data, no parity, and 1 stop bit). The parameters like the baud rate, parity bit, etc., are initialized by the Arduino at the beginning of the procedure. The text to send is stored in the PROGMEM section of the microcontroller memory, allowing the Arduino to send long messages without any stack problems. No external crystal is needed, as the program utilizes Timer2 of the ATmega328P microcontroller on the Arduino UNO board to generate the clock signal, and achieve the desired standard 9600 Baud rate.

### Register Initialization for Basic 9600 Baud 8N1 Serial Transmission
  - The circuit works like the following: The Arduino sends 8-bit ASCII characters to the UART chip, then the chip converts it to serial data. The parameters like the baudrate, parity bit, etc are also initialized by the Arduino in the beginning of the procedure. 
  - The text to send is divided into characters, as the function handles ASCII 8-bit chars.
  - In this circuit the clock pulse is generated by the Arduino itself, so no crystal is needed!
  
  To initialize the UART registers for communication, the Arduino program follows these steps:

1. **Delay for Stability**: After power-up, a short delay is introduced to ensure stability.
2. **Chip Initialization**:
   - **Disable Chip**: The chip is disabled by setting the chip enable (CEN) pin to LOW.
   - **Reset Chip**: A reset sequence is initiated by toggling the RESET pin.
   - **Data Set Ready and Data Carrier Detect**: Data set ready (DSRN) and data carrier detect (DCDN) pins are set to HIGH.
   - **Clear to Send**: Clear to send (CTSN) pin is set to LOW.
   - **Address and Read/Write Setup**: Address lines (ADDRESS0 and ADDRESS1) are configured, and the read/write (RWN) line is set to HIGH.
3. **Configure Mode Register 1 (MR1)**:
   - The chip is enabled temporarily.
   - Data is written to the data bus to configure Mode Register 1 (MR1).
4. **Configure Mode Register 2 (MR2)**:
   - The chip is enabled temporarily.
   - Data is written to the data bus to configure Mode Register 2 (MR2).
5. **Configure Command Register (CR)**:
   - The chip is enabled temporarily.
   - Data is written to the data bus to configure the Command Register (CR).
6. **End of Initialization**: A blink LED function is called to indicate the completion of initialization.

This sequence initializes the SNC2651 PCI UART chip for UART communication, configuring the necessary control lines and registers for proper operation.

## Schematic

![Schematic](https://github.com/bazsimarkus/Simple-2651-UART-System-with-Arduino/raw/main/images/2651_sch.png)

## 2651 Properties

The 2651 PCI UART (Programmable Communications Interface, Universal Asynchronous Receiver-Transmitter) chip was originally developed by Signetics. This chip was part of the Signetics 2650 family and was widely used in serial communication. Over the years, it has undergone several enhancements and adaptations to meet evolving industry standards and technological advancements in serial communication. Its reliability and performance have made it a preferred choice for a wide range of applications, from industrial automation to telecommunications, contributing significantly to the advancement of serial data transmission technologies.

### Pinout of the 2651 PCI UART chip (DIP-28)

```plaintext
         ┌───────○───────┐
      D2 │1            28│ D1
      D3 │2            27│ D0
     RxD │3            26│ VCC 
     GND │4            25│ RxCN 
      D4 │5            24│ DTRN  
      D5 │6     2651   23│ RTSN
      D6 │7     UART   22│ DSRN 
      D7 │8            21│ RESET
    TxCN │9            20│ BRCLK
      A1 │10           19│ TxD   
     CEN │11           18│ TxEMTN_DSCHGN
      A0 │12           17│ CTSN  
     RWN │13           16│ DCDN   
  RxRDYN │14           15│ TxRDYN   
         └───────────────┘
```

### Pin Descriptions of the 2651 PCI UART chip

| Pin Number | Name            | Type    | Description                          |
|------------|-----------------|---------|--------------------------------------|
| 1          | D2              | In/Out  | Data Bit 2                           |
| 2          | D3              | In/Out  | Data Bit 3                           |
| 3          | RxD             | In      | Receive Data                         |
| 4          | GND             | -       | Ground                               |
| 5          | D4              | In/Out  | Data Bit 4                           |
| 6          | D5              | In/Out  | Data Bit 5                           |
| 7          | D6              | In/Out  | Data Bit 6                           |
| 8          | D7              | In/Out  | Data Bit 7                           |
| 9          | TxCN            | In/Out  | Transmit Clock  (Active Low)         |
| 10         | A1              | In      | Address Bit 1                        |
| 11         | CEN             | In      | Chip Enable  (Active Low)            |
| 12         | A0              | In      | Address Bit 0                        |
| 13         | RWN             | In      | Read/Write (Active Low)              |
| 14         | RxRDYN          | Out     | Receiver ready (Active Low)          |
| 15         | TxRDYN          | Out     | Transmitter ready (Active Low)       |
| 16         | DCDN            | In      | Data Carrier Detect (Active Low)     |
| 17         | CTSN            | In      | Clear To Send (Active Low)           |
| 18         | TxEMTN_DSCHGN   | Out     | Serialization complete (Active Low)  |
| 19         | TxD             | Out     | Transmit Data                        |
| 20         | BRCLK           | In      | Baud Rate Clock (for internal clock) |
| 21         | RESET           | In      | Reset                                |
| 22         | DSRN            | In      | General Purpose Input (Active Low)   |
| 23         | RTSN            | Out     | Request To Send (Active Low)         |
| 24         | DTRN            | Out     | Data Terminal Ready (Active Low)     |
| 25         | RxCN            | In/Out  | Receiver Clock  (Active Low)         |
| 26         | Vcc             | -       | 5V Positive Supply                   |
| 27         | D0              | In/Out  | Data Bit 0                           |
| 28         | D1              | In/Out  | Data Bit 1                           |

  > **NOTE:** The RxCN and TxCN pins have short circuit protection in output mode (max. CL = 100pF)

### Register Descriptions for the 2651 PCI UART chip

The initUart() function initializes the PCI UART chip by configuring the control register to set the clock divisor, data format, and interrupt control. It sets the clock divisor to 16x, selects a 8 data bits, no parity, 1 stop bit (8n1) format, and disables transmitter and receiver interrupts. Additionally, it configures the PCI's control lines for proper operation by setting appropriate digital signals.

The SYN1, SYN2, and DLE registers are accessed by performing write operations with the conditions A1 = 0, A0 = 1, and R/W = 1. The first operation loads the SYN1 register. The next loads the SYN2 register, and the third loads the DLE register. Reading or loading the mode registers is done in a similar manner. The first write (or read) operation addresses mode register 1, and a subsequent operation addresses mode register 2. If more than the required number of accesses are made, the internal sequencer recycles to point at the first register. The pointers are reset to SYN1 register and mode register 1 by a RESET input or by performing a “read command register” operation, but are unaffected by any other read or write operation. The SCN2651 register formats are summarized in the following lists. Mode registers 1 and 2 define the general operational characteristics of the PCI, while the command register controls the operation within this basic framework. The PCI indicates its status in the status register. These registers are cleared when a RESET input is applied.

**Mode Register 1 (MR1):**
- MR17: Number of SYN characters (0 = Double SYN, 1 = Single SYN)
- MR16: Transparency control (0 = Normal, 1 = Transparent)
- MR15: Parity type (0 = Odd, 1 = Even)
- MR14: Parity control (0 = Disabled, 1 = Enabled)
- MR13-MR12: Character length (00 = 5 Bits, 01 = 6 Bits, 10 = 7 Bits, 11 = 8 Bits)
- MR11-MR10: Mode and baud rate factor (00 = Synchronous 1X rate, 01 = Asynchronous 1X rate, 10 = Asynchronous 16X rate, 11 = Asynchronous 64X rate)
  Note: Baud rate factor in asynchronous applies only if external clock is selected. Factor is 16X if internal clock is selected. Mode must be selected (MR11, MR10) in any case

**Mode Register 2 (MR2):**
- MR27-MR26: Not used
- MR25: Transmitter clock source (0 = External, 1 = Internal)
- MR24: Receiver clock source (0 = External, 1 = Internal)
- MR23-MR20: Baud rate selection (0000 = 50 Baud, ..., 1111 = 19,200 Baud)

**Command Register (CR):**
- CR7-CR6: Operating mode (00 = Normal operation, 01 = Echo/Stripping mode, 10 = Local Loopback, 11 = Remote Loopback)
- CR5: Request to send (0 = High, 1 = Low)
- CR4: Reset error flags (0 = Normal, 1 = Reset error flags)
- CR3: Transmit control (Async: Force break, Sync: Send DLE)
- CR2: Receive control (0 = Disable, 1 = Enable)
- CR1: Data terminal ready (0 = High, 1 = Low)
- CR0: Transmit control (0 = Disable, 1 = Enable)

## Development

The project was developed using the [Arduino IDE](https://www.arduino.cc/), and testing was conducted with [RealTerm](https://realterm.sourceforge.io/).

Here you can see a screenshot of the result:

![Screenshot](https://raw.githubusercontent.com/bazsimarkus/Simple-2651-UART-System-with-Arduino/main/images/2651_screenshot.png)

## Notes

Check out my other serial test circuit projects, developed concurrently with this circuit!
